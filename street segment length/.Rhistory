# -logLik gives the minus log-likelihood since mle maximizes log-likelihood
-as.numeric(logLik(res))
})
# Find the index of the minimum minus log-likelihood
best_index <- which.min(mll_values)
best_result <- valid_results[[best_index]]
start_grid <- list(
c(alpha = 150),
c(alpha = 200),
c(alpha = 250),
c(alpha = 300),
c(alpha = 400),
c(alpha = 500),
c(alpha = 100),
c(alpha = 50)
)
results_list <- vector("list", length(start_grid))
for (i in seq_along(start_grid)) {
init <- start_grid[[i]]
cat("Trying initialization:", init, "\n")
# Use tryCatch to handle potential errors during estimation
est <- tryCatch({
mle(
minus_log_likelihood_model_5,
start = init,
method = "L-BFGS-B",
lower = c(alpha = 0),
upper = c(alpha = Inf)
)
}, error = function(e) {
message("Error with initialization ", i, ": ", e$message)
return(NULL)  # return NULL on failure
})
results_list[[i]] <- est
}
# Filter out NULL entries from failed fits
valid_results <- Filter(Negate(is.null), results_list)
# Extract minus log-likelihood values from each valid result
mll_values <- sapply(valid_results, function(res) {
# -logLik gives the minus log-likelihood since mle maximizes log-likelihood
-as.numeric(logLik(res))
})
# Find the index of the minimum minus log-likelihood
best_index <- which.min(mll_values)
best_result <- valid_results[[best_index]]
# 3) Parameter estimation via MLE
# Define a list of starting parameter vectors
start_grid <- list(
c(alpha = 150),
c(alpha = 200),
c(alpha = 250),
c(alpha = 300),
c(alpha = 400),
c(alpha = 500),
c(alpha = 100),
c(alpha = 50),
c(alpha = 5000)
)
results_list <- vector("list", length(start_grid))
for (i in seq_along(start_grid)) {
init <- start_grid[[i]]
cat("Trying initialization:", init, "\n")
# Use tryCatch to handle potential errors during estimation
est <- tryCatch({
mle(
minus_log_likelihood_model_5,
start = init,
method = "L-BFGS-B",
lower = c(alpha = 0),
upper = c(alpha = Inf)
)
}, error = function(e) {
message("Error with initialization ", i, ": ", e$message)
return(NULL)  # return NULL on failure
})
results_list[[i]] <- est
}
# Filter out NULL entries from failed fits
valid_results <- Filter(Negate(is.null), results_list)
# Extract minus log-likelihood values from each valid result
mll_values <- sapply(valid_results, function(res) {
# -logLik gives the minus log-likelihood since mle maximizes log-likelihood
-as.numeric(logLik(res))
})
# Find the index of the minimum minus log-likelihood
best_index <- which.min(mll_values)
best_result <- valid_results[[best_index]]
# 3) Parameter estimation via MLE
# Define a list of starting parameter vectors
start_grid <- list(
c(alpha = 150),
c(alpha = 200),
c(alpha = 250),
c(alpha = 300),
c(alpha = 400),
c(alpha = 500),
c(alpha = 100),
c(alpha = 50),
c(alpha = 5000),
c(alpha = 5)
)
results_list <- vector("list", length(start_grid))
for (i in seq_along(start_grid)) {
init <- start_grid[[i]]
cat("Trying initialization:", init, "\n")
# Use tryCatch to handle potential errors during estimation
est <- tryCatch({
mle(
minus_log_likelihood_model_5,
start = init,
method = "L-BFGS-B",
lower = c(alpha = 0),
upper = c(alpha = Inf)
)
}, error = function(e) {
message("Error with initialization ", i, ": ", e$message)
return(NULL)  # return NULL on failure
})
results_list[[i]] <- est
}
# Filter out NULL entries from failed fits
valid_results <- Filter(Negate(is.null), results_list)
# Extract minus log-likelihood values from each valid result
mll_values <- sapply(valid_results, function(res) {
# -logLik gives the minus log-likelihood since mle maximizes log-likelihood
-as.numeric(logLik(res))
})
# Find the index of the minimum minus log-likelihood
best_index <- which.min(mll_values)
best_result <- valid_results[[best_index]]
# 3) Parameter estimation via MLE
# Define a list of starting parameter vectors
start_grid <- list(
c(alpha = 150),
c(alpha = 200),
c(alpha = 250),
c(alpha = 300),
c(alpha = 400),
c(alpha = 500),
c(alpha = 100),
c(alpha = 50),
c(alpha = 5000),
c(alpha = 5),
c(alpha = 500000000)
)
results_list <- vector("list", length(start_grid))
for (i in seq_along(start_grid)) {
init <- start_grid[[i]]
cat("Trying initialization:", init, "\n")
# Use tryCatch to handle potential errors during estimation
est <- tryCatch({
mle(
minus_log_likelihood_model_5,
start = init,
method = "L-BFGS-B",
lower = c(alpha = 0),
upper = c(alpha = Inf)
)
}, error = function(e) {
message("Error with initialization ", i, ": ", e$message)
return(NULL)  # return NULL on failure
})
results_list[[i]] <- est
}
# Filter out NULL entries from failed fits
valid_results <- Filter(Negate(is.null), results_list)
# Extract minus log-likelihood values from each valid result
mll_values <- sapply(valid_results, function(res) {
# -logLik gives the minus log-likelihood since mle maximizes log-likelihood
-as.numeric(logLik(res))
})
# Find the index of the minimum minus log-likelihood
best_index <- which.min(mll_values)
best_result <- valid_results[[best_index]]
# Define a list of starting parameter vectors
start_grid <- list(
c(alpha = 150),
c(alpha = 200),
c(alpha = 250),
c(alpha = 300),
c(alpha = 400),
c(alpha = 500),
c(alpha = 100),
c(alpha = 50),
c(alpha = 5000),
c(alpha = 5),
c(alpha = 500000000),
c(alpha = 0.1)
)
results_list <- vector("list", length(start_grid))
for (i in seq_along(start_grid)) {
init <- start_grid[[i]]
cat("Trying initialization:", init, "\n")
# Use tryCatch to handle potential errors during estimation
est <- tryCatch({
mle(
minus_log_likelihood_model_5,
start = init,
method = "L-BFGS-B",
lower = c(alpha = 0),
upper = c(alpha = Inf)
)
}, error = function(e) {
message("Error with initialization ", i, ": ", e$message)
return(NULL)  # return NULL on failure
})
results_list[[i]] <- est
}
# Filter out NULL entries from failed fits
valid_results <- Filter(Negate(is.null), results_list)
# Extract minus log-likelihood values from each valid result
mll_values <- sapply(valid_results, function(res) {
# -logLik gives the minus log-likelihood since mle maximizes log-likelihood
-as.numeric(logLik(res))
})
# Find the index of the minimum minus log-likelihood
best_index <- which.min(mll_values)
best_result <- valid_results[[best_index]]
params <- c(alpha = 100)
l_seq <- seq(min(df$length), max(df$length), length.out = 300)
# Compute normalization constants
C <- compute_normalization_constant_model_5(params["alpha"])
# Compute densities for each model at the sequence of lengths
density <- C * exp(-params["alpha"] / l_seq)
model_df <- data.frame(length = l_seq, density = density, model = "Best Model")
ggplot() +
# Original data density plot
geom_point(
data = df,
aes(x = length, y = approx(dens$x, dens$y, xout = length)$y),
color = "steelblue", alpha = 0.6
) +
geom_line(
data = df,
aes(x = length, y = approx(dens$x, dens$y, xout = length)$y),
color = "steelblue", size = 0.5
) +
# Overlay model predictions
geom_line(
data = model_df,
aes(x = length, y = density, color = model),
size = 1
) +
# Log-log scales and labels
scale_x_log10() +
labs(
title = "Barcelona's Street Length Distribution (Log-Log)",
x = "Street Length (m)",
y = "Density"
) +
theme_minimal() +
theme(
axis.text = element_text(size = 12),
axis.title = element_text(size = 14),
legend.position = "bottom"  # Show legend to distinguish models
)
ggplot() +
# Original data density plot
geom_point(
data = df,
aes(x = length, y = approx(dens$x, dens$y, xout = length)$y),
color = "steelblue", alpha = 0.6
) +
geom_line(
data = df,
aes(x = length, y = approx(dens$x, dens$y, xout = length)$y),
color = "steelblue", size = 0.5
) +
# Overlay model predictions
geom_line(
data = model_df,
aes(x = length, y = density, color = model),
size = 1
) +
# Log-log scales and labels
scale_x_log10() +
scale_y_log10() +
labs(
title = "Barcelona's Street Length Distribution (Log-Log)",
x = "Street Length (m)",
y = "Density"
) +
theme_minimal() +
theme(
axis.text = element_text(size = 12),
axis.title = element_text(size = 14),
legend.position = "bottom"  # Show legend to distinguish models
)
params <- c(alpha = 10)
l_seq <- seq(min(df$length), max(df$length), length.out = 300)
# Compute normalization constants
C <- compute_normalization_constant_model_5(params["alpha"])
# Compute densities for each model at the sequence of lengths
density <- C * exp(-params["alpha"] / l_seq)
model_df <- data.frame(length = l_seq, density = density, model = "Best Model")
ggplot() +
# Original data density plot
geom_point(
data = df,
aes(x = length, y = approx(dens$x, dens$y, xout = length)$y),
color = "steelblue", alpha = 0.6
) +
geom_line(
data = df,
aes(x = length, y = approx(dens$x, dens$y, xout = length)$y),
color = "steelblue", size = 0.5
) +
# Overlay model predictions
geom_line(
data = model_df,
aes(x = length, y = density, color = model),
size = 1
) +
# Log-log scales and labels
scale_x_log10() +
scale_y_log10() +
labs(
title = "Barcelona's Street Length Distribution (Log-Log)",
x = "Street Length (m)",
y = "Density"
) +
theme_minimal() +
theme(
axis.text = element_text(size = 12),
axis.title = element_text(size = 14),
legend.position = "bottom"  # Show legend to distinguish models
)
params <- c(alpha = 1)
l_seq <- seq(min(df$length), max(df$length), length.out = 300)
# Compute normalization constants
C <- compute_normalization_constant_model_5(params["alpha"])
# Compute densities for each model at the sequence of lengths
density <- C * exp(-params["alpha"] / l_seq)
model_df <- data.frame(length = l_seq, density = density, model = "Best Model")
ggplot() +
# Original data density plot
geom_point(
data = df,
aes(x = length, y = approx(dens$x, dens$y, xout = length)$y),
color = "steelblue", alpha = 0.6
) +
geom_line(
data = df,
aes(x = length, y = approx(dens$x, dens$y, xout = length)$y),
color = "steelblue", size = 0.5
) +
# Overlay model predictions
geom_line(
data = model_df,
aes(x = length, y = density, color = model),
size = 1
) +
# Log-log scales and labels
scale_x_log10() +
scale_y_log10() +
labs(
title = "Barcelona's Street Length Distribution (Log-Log)",
x = "Street Length (m)",
y = "Density"
) +
theme_minimal() +
theme(
axis.text = element_text(size = 12),
axis.title = element_text(size = 14),
legend.position = "bottom"  # Show legend to distinguish models
)
compute_normalization_constant_model_6 <- function(beta, l_min = 1e-6, l_max = Inf) {
f_unnormalized <- function(l, beta) {
exp(-beta * l)
}
result <- try(integrate(f_unnormalized,
lower = l_min, upper = l_max,
beta = beta),
silent = TRUE)
if (inherits(result, "try-error") || !is.finite(result$value) || result$message != "OK") {
return(NA)
}
return(1 / result$value)
}
# 2) Compute the minus log-likelihood for Model 6
minus_log_likelihood_model_6 <- function(beta) {
C <- compute_normalization_constant_model_6(beta)
if (is.na(C) || !is.finite(C)) {
return(1e12)
}
value <- -sum(log(C * exp(-beta * df$length)))
if (!is.finite(value)) {
return(1e12)
}
return(value)
}
# 3) Parameter estimation via MLE
# Define a list of starting parameter vectors
start_grid <- list(
c(beta = 0.1),
c(beta = 0.01),
c(beta = 0.001),
c(beta = 0.0001),
c(beta = 0.00001),
c(beta = 0.000001)
)
results_list <- vector("list", length(start_grid))
for (i in seq_along(start_grid)) {
init <- start_grid[[i]]
cat("Trying initialization:", init, "\n")
# Use tryCatch to handle potential errors during estimation
est <- tryCatch({
mle(
minus_log_likelihood_model_6,
start = init,
method = "L-BFGS-B",
lower = c(beta = 0),
upper = c(beta = Inf)
)
}, error = function(e) {
message("Error with initialization ", i, ": ", e$message)
return(NULL)  # return NULL on failure
})
results_list[[i]] <- est
}
# Filter out NULL entries from failed fits
valid_results <- Filter(Negate(is.null), results_list)
# Extract minus log-likelihood values from each valid result
mll_values <- sapply(valid_results, function(res) {
# -logLik gives the minus log-likelihood since mle maximizes log-likelihood
-as.numeric(logLik(res))
})
# Find the index of the minimum minus log-likelihood
best_index <- which.min(mll_values)
best_result <- valid_results[[best_index]]
cat("Best initialization resulted in:\n")
print(best_result)
cat("Minimum minus log-likelihood:", mll_values[best_index], "\n")
get_AIC(minus_log_likelihood_model_4(beta = 0.01001878), 1, length(df$length))
get_AIC(minus_log_likelihood_model_6(beta = 0.01001878), 1, length(df$length))
params <- c(beta = 0.01001878)
l_seq <- seq(min(df$length), max(df$length), length.out = 300)
# Compute normalization constants
C <- compute_normalization_constant_model_6(params["beta"])
# Compute densities for each model at the sequence of lengths
density <- C * exp(-params["beta"] * l_seq)
model_df <- data.frame(length = l_seq, density = density, model = "Best Model")
ggplot() +
# Original data density plot
geom_point(
data = df,
aes(x = length, y = approx(dens$x, dens$y, xout = length)$y),
color = "steelblue", alpha = 0.6
) +
geom_line(
data = df,
aes(x = length, y = approx(dens$x, dens$y, xout = length)$y),
color = "steelblue", size = 0.5
) +
# Overlay model predictions
geom_line(
data = model_df,
aes(x = length, y = density, color = model),
size = 1
) +
# Log-log scales and labels
scale_x_log10() +
scale_y_log10() +
labs(
title = "Barcelona's Street Length Distribution (Log-Log)",
x = "Street Length (m)",
y = "Density"
) +
theme_minimal() +
theme(
axis.text = element_text(size = 12),
axis.title = element_text(size = 14),
legend.position = "bottom"  # Show legend to distinguish models
)
params <- c(beta = 0.01001878)
l_seq <- seq(min(df$length), max(df$length), length.out = 300)
# Compute normalization constants
C <- compute_normalization_constant_model_6(params["beta"])
# Compute densities for each model at the sequence of lengths
density <- C * exp(-params["beta"] * l_seq)
model_df <- data.frame(length = l_seq, density = density, model = "Best Model")
ggplot() +
# Original data density plot
geom_point(
data = df,
aes(x = length, y = approx(dens$x, dens$y, xout = length)$y),
color = "steelblue", alpha = 0.6
) +
geom_line(
data = df,
aes(x = length, y = approx(dens$x, dens$y, xout = length)$y),
color = "steelblue", size = 0.5
) +
# Overlay model predictions
geom_line(
data = model_df,
aes(x = length, y = density, color = model),
size = 1
) +
# Log-log scales and labels
scale_x_log10() +
labs(
title = "Barcelona's Street Length Distribution (Log-Log)",
x = "Street Length (m)",
y = "Density"
) +
theme_minimal() +
theme(
axis.text = element_text(size = 12),
axis.title = element_text(size = 14),
legend.position = "bottom"  # Show legend to distinguish models
)
